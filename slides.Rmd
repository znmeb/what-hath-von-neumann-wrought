---
title: "What Hath Von Neumann Wrought?"
author: "M. Edward (Ed) Borasky"
date: "June 23, 2016"
output:
  revealjs::revealjs_presentation:
    incremental: yes
  slidy_presentation:
    incremental: yes
  ioslides_presentation:
    incremental: yes
---
# Motivation

## Standing on the shoulders of giants
* "If I have seen farther than others, it is because I was standing on the shoulders of giants." - Isaac Newton 
* "If I have not seen as far as others, it is because giants were standing on my shoulders." - Hal Abelson 
* "In computer science, we stand on each other's feet." - Brian Reid
* "How many people can stand on the shoulders of a giant before the giant collapses?" - znmeb

## We program today in a rich environment
* numerous abstract programming paradigms,
* elegant realizations of those paradigms in programming languages,
* well-crafted run-times, interpreters and compilers,
* distributed version control systems for collaboration,
* integrated development environments, and
* documentation tools.

## Programming paradigms (mid 1960s to the present)
* Object-oriented programming
    - [Simula67](https://en.wikipedia.org/wiki/Simula) (1967), [Smalltalk-80](https://en.wikipedia.org/wiki/Smalltalk) (1980)
* Functional programming
    - [OCaml](https://en.wikipedia.org/wiki/OCaml) (1996), [Haskell](https://en.wikipedia.org/wiki/Haskell_(programming_language)) (1990)
* Array programming
    - [MATLAB](https://en.wikipedia.org/wiki/MATLAB) (1984), [S](https://en.wikipedia.org/wiki/S_(programming_language)) (1976), [R](https://en.wikipedia.org/wiki/R_(programming_language)) (1994), [APL](https://en.wikipedia.org/wiki/APL_(programming_language)) (1966)

## What made all this possible?
* Transistor logic
* Magnetic core random access memory
* General-purpose architectures like [System\\360](https://en.wikipedia.org/wiki/IBM_System/360) (1964)

## And before that?
* Two kinds of computers - "scientific" and "business"
* Two languages - FORTRAN and COBOL

## May 25, 1961 - July 20, 1969
[John F. Kennedy's Moon Speech to Congress - May 25, 1961](https://youtu.be/Kza-iTe2100)

## \<rant\>

![](likehell.jpg)

## Like Hell It Was!
* By July of 1969, large System\\360 mainframes were in use at NASA
* Even in 1961, the state of the art was an [IBM 7090](https://en.wikipedia.org/wiki/IBM_7090)
* \</rant\>

## I've taken away ...
* Your IDEs, version control, the Internet
    - Sorry, you can't Google an error message any more
* Your programming paradigms
* But hey, at least you've got FORTRAN and COBOL
* At least your computer's transistorized

## April 1957
* The first [FORTRAN](https://en.wikipedia.org/wiki/Fortran) compiler is delivered ...
* For the [IBM 704](https://en.wikipedia.org/wiki/IBM_704) ... a vacuum tube machine
* With floating point hardware and index registers
* And magnetic core memory
* I'm not finished

## April 1952
* The [IBM 701](https://en.wikipedia.org/wiki/IBM_701) is announced
* No floating point
* No index registers
* Cathode ray tube memory
* ***Based on the [IAS machine](https://en.wikipedia.org/wiki/IAS_machine)***

## And so, time travelers, we've arrived at our destination

What Hath Von Neumann (and many others) Wrought?

# The IAS Machines

## State of scientific computing

## Preliminary discussions

## Why I made such a big deal out of floating point and index registers

## Planning and coding

## Hardware
* MANIAC
* JOHNNIAC
* ILLIAC and copies

# The architecture

## Arithmetic unit

```{r echo = FALSE}
DiagrammeR::grViz("arith_unit.gv")
```

## The accumulator (A) and quotient register (Q) coupled

```{r echo = FALSE}
DiagrammeR::grViz("aq.gv")
```

## Left Shifting = multiply AQ by two
1. Shift a0 -> bit bucket
2. Shift a1:a39 -> a0:a38
3. Leave q0 alone!
4. Shift q1 -> a39
5. Shift q2:q39 -> q1:q38
6. Zero -> q39

## Right Shifting = divide AQ by two
1. Shift q39 -> bit bucket
2. Shift q1:q38 -> q2:q39
3. Leave q0 alone!
4. Shift a39 -> q1
5. Shift a0:a38 -> a1:a39
6. Keep original a0!

## Adding
1. Augend
    * Clear A, or
    * Hold A, or
    * Set A = 1/2
2. Addend
    * Memory word or Q to R3, then
3. Complement gate
    * Pass straight through, or
    * Negate, or
    * Absolute value
3. Form sum in A

## Multiplication: initialization
1. Multiplier is in Q
2. Multiplicand is in R3
3. Accumulator
    * Clear A, or
    * Hold A, or
    * Set A = 1/2
4. Complement gate
    * Pass straight through, or
    * Negate, or
    * Absolute value

## Multiplication: iteration
39 steps of

* A <- A + Complement gate
* Shift AQ right one bit

## Dividing
1. Double-length dividend in AQ
2. Divisor is in R3
3. 39 steps of
    * subtract R3 from A in the adder
    * if the result is less than zero, set q39 to 0
    * if the result is greater than or equal to zero, set q39 to 1 and copy the difference to A
    * shift AQ left one place, copying q1 into q0
4. Set q39 to 1 for rounding

## Control

## Input / Output

# The software engineering process

## Algorithms
* Calculus / differential equations
* Statistics / Monte Carlo
* Linear algebra / linear equations / eigensystems

## Memory layout

## Assembler / loader

## Run

## Debugging / post-mortem

# The emulator

## Existing emulators
* simh
* SILLIAC
* misc

## Why build a new one?

